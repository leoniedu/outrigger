---
title: "Desafio 60K 2025 - Otimiza√ß√£o de Rota√ß√£o"
subtitle: "An√°lise de revezamento para canoa havaiana OC6"
author: "Outrigger Optimizer"
date: today
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    theme: cosmo
execute:
  warning: false
---

## Introdu√ß√£o

Este documento apresenta a an√°lise de otimiza√ß√£o de rota√ß√£o para o **Desafio 60K 2025**.
O objetivo √© encontrar a dura√ß√£o ideal de cada turno (per√≠odo de remada) que minimize o tempo total de prova, considerando:

- **Fadiga**: remadores perdem efici√™ncia ao longo de turnos consecutivos
- **Trocas**: cada troca de tripula√ß√£o adiciona tempo √† prova
- **Elegibilidade**: cada remador s√≥ pode ocupar determinados bancos



## Configura√ß√£o da Prova

```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from outrigger_opt import optimize_stint_range, solve_rotation_cycle

# Configura√ß√£o da prova
DISTANCIA_KM = 60
VELOCIDADE_KMH = 10
TEMPO_TROCA_SECS = 20
```

### Tripula√ß√£o

A tripula√ß√£o √© composta por 9 remadores, onde 6 remam e 3 descansam a cada turno.

```{python}
paddlers = pd.DataFrame({
    'name': ['Eduardo', 'Vitor', 'Guilherme', 'Ricardo', 'Airton',
             'Everson', 'Sergio', 'Marcelo', 'Z√©']
})

# Habilidade relativa de cada remador (1.0 = m√©dia)
habilidade = [1.01, 1, 1, 1, 1, 1.03, 1, 1, 1.02]

print("Tripula√ß√£o e habilidades:")
for nome, hab in zip(paddlers['name'], habilidade):
    #emoji = "üí™" if hab > 1.0 else ("üò¥" if hab < 1.0 else "")
    print(f"  {nome}: {hab:.0%}")
```

### Matriz de Elegibilidade

Cada remador s√≥ pode ocupar determinados bancos, baseado em sua experi√™ncia e posi√ß√£o preferida.

```{python}
#| label: tbl-elegibilidade
#| tbl-cap: "Matriz de Elegibilidade (1 = pode sentar, 0 = n√£o pode)"

eligibility = np.array([
    [1, 1, 0, 0, 0, 0],  # Eduardo: Voga/contra-voga
    [1, 1, 0, 0, 0, 0],  # Vitor: Voga/contra-voga
    [1, 1, 0, 0, 0, 0],  # Guilherme: Voga/contra-voga
    [0, 0, 1, 0, 0, 0],  # Ricardo: hip
    [0, 0, 0, 0, 1, 0],  # Airton: 5
    [0, 0, 1, 1, 0, 0],  # Everson: hip+4
    [0, 0, 1, 1, 0, 0],  # Sergio: hip+4
    [0, 0, 0, 0, 1, 1],  # Marcelo: 5 + leme
    [0, 0, 0, 0, 1, 1],  # Z√©: 5 + leme
])

# Criar DataFrame para visualiza√ß√£o
df_elig = pd.DataFrame(
    eligibility,
    index=paddlers['name'],
    columns=['Banco 1 (Voga)', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6 (Leme)']
)
df_elig.replace({1: '‚úì', 0: ''})
```

```{python}
#| fig-cap: "Mapa de elegibilidade dos remadores"

# Calculate average and std of eligible seat positions for each paddler
seat_positions = np.arange(1, 7)  # 1-6
paddler_stats = []
for i, name in enumerate(paddlers['name']):
    eligible_seats = seat_positions[eligibility[i] == 1]
    avg_seat = eligible_seats.mean()
    std_seat = eligible_seats.std() if len(eligible_seats) > 1 else 0
    paddler_stats.append((i, name, avg_seat, std_seat))

# Sort by average (increasing), then by std (decreasing)
paddler_stats.sort(key=lambda x: (x[2], -x[3]))
sorted_indices = [s[0] for s in paddler_stats]
sorted_names = [s[1] for s in paddler_stats]
sorted_eligibility = eligibility[sorted_indices]

fig, ax = plt.subplots(figsize=(10, 6))
im = ax.imshow(sorted_eligibility, cmap='Blues', aspect='auto')

ax.set_xticks(range(6))
ax.set_xticklabels(['Banco 1 (Voga)', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6 (Leme)'])
ax.set_yticks(range(9))
ax.set_yticklabels(sorted_names)

# Adicionar texto nas c√©lulas
for i in range(9):
    for j in range(6):
        text = '‚úì' if sorted_eligibility[i, j] == 1 else ''
        ax.text(j, i, text, ha='center', va='center', fontsize=14)

ax.set_title('Matriz de Elegibilidade', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()
```

## Justificativa dos Par√¢metros

### Padr√£o de Entrada nos Bancos

A rota√ß√£o tradicional (equipes experientes) segue o padr√£o:

- **Voga**: Remador descansado entra no **banco 1 (voga)** e passa pro 2 na troca seguinte ‚Äî assim o voga est√° sempre "fresco" (l√° ele)

Para a equipe **Caveiras**, invertemos esse padr√£o:

::: {.callout-note}
## Adapta√ß√£o para Caveiras
**Voga**: Entrar no banco 2 primeiro, esquentar, depois ir pro banco 1.

*Justificativa*: O atleta vai subir pro banco 1 provavelmente frio, dificilmente acertar√° o ritmo de imediato. Melhor entrar no 2, esquentar e acompanhar o voga anterior, e s√≥ depois ir pro 1.

**Leme**: Marcelo entra no banco 5, depois vai pro 5. Z√© direto no 6.
:::

### Pesos de Entrada (`seat_entry_weights`)

Os pesos refletem a prefer√™ncia de entrada em cada banco (maior = preferido para entrada):

```{python}
seat_entry_weights = [1, 1.2, 1.2, 1.2, 2, 1]
seat_names = ['Banco 1 (Voga)', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6 (Leme)']

pd.DataFrame({
    'Banco': seat_names,
    'Peso': seat_entry_weights
}).set_index('Banco')
```

### Dura√ß√£o do turno


## Otimiza√ß√£o

Testamos dura√ß√µes de turno entre **10 e 20 minutos** para encontrar o tempo √≥timo.

```{python}
#| output: false

results = optimize_stint_range(
    paddlers,
    stint_range=range(8, 20),
    seat_eligibility=eligibility,
    seat_weights=[1.05, 1.02, 1.02, 1.01, 1.00, 1.10],
    seat_entry_weights=seat_entry_weights,
    paddler_ability=habilidade,
    distance_km=DISTANCIA_KM,
    speed_kmh=VELOCIDADE_KMH,
    switch_time_secs=TEMPO_TROCA_SECS,
    max_consecutive=3,
    solver_time_secs=60,
    gap_tolerance=0.001,
)
```

### Compara√ß√£o de Tempos

```{python}
#| label: fig-comparacao
#| fig-cap: "Tempo de prova vs. dura√ß√£o do turno"

summary = results['summary']

fig, ax = plt.subplots(figsize=(10, 6))

# Gr√°fico principal
ax.plot(summary['stint_min'], summary['race_time'], 'b-o', linewidth=2, markersize=8)

# Destacar o melhor
best_idx = summary['race_time'].idxmin()
best_stint = int(summary.loc[best_idx, 'stint_min'])
best_time = summary.loc[best_idx, 'race_time']

ax.scatter([best_stint], [best_time], color='red', s=200, zorder=5, label=f'√ìtimo: {best_stint} min')
ax.axhline(y=best_time, color='red', linestyle='--', alpha=0.5)
ax.axvline(x=best_stint, color='red', linestyle='--', alpha=0.5)

ax.set_xlabel('Dura√ß√£o do Turno (minutos)', fontsize=12)
ax.set_ylabel('Tempo Total de Prova (minutos)', fontsize=12)
ax.set_title('Otimiza√ß√£o da Dura√ß√£o do Turno', fontsize=14, fontweight='bold')
ax.legend()
ax.grid(True, alpha=0.3)

# Adicionar anota√ß√£o
ax.annotate(f'{best_time:.1f} min\n({best_time/60:.1f} horas)',
            xy=(best_stint, best_time),
            xytext=(best_stint + 2, best_time + 3),
            fontsize=11,
            arrowprops=dict(arrowstyle='->', color='red'))

plt.tight_layout()
plt.show()
```

### Tabela de Resultados

```{python}
#| label: tbl-resultados
#| tbl-cap: "Compara√ß√£o de tempos por dura√ß√£o de turno"

summary_display = summary.copy()
summary_display['race_time_hours'] = summary_display['race_time'] / 60
summary_display['speed'] = DISTANCIA_KM / summary_display['race_time_hours']
summary_display.columns = ['Turno (min)', 'N¬∫ turnos', 'Output M√©dio', 'Tempo (min)', 'Tempo (horas)', 'Velocidade (km/h)']
summary_display['Output M√©dio'] = summary_display['Output M√©dio'].apply(lambda x: f'{x:.1%}')
summary_display['Tempo (horas)'] = summary_display['Tempo (horas)'].apply(lambda x: f'{x:.2f}')
summary_display['Velocidade (km/h)'] = summary_display['Velocidade (km/h)'].apply(lambda x: f'{x:.2f}')
summary_display = summary_display.drop(columns=['Tempo (min)'])
summary_display.set_index('Turno (min)', inplace=True)
summary_display
```

### Trade-off: Trocas vs. Fadiga

```{python}
#| label: fig-tradeoff
#| fig-cap: "An√°lise do trade-off entre n√∫mero de trocas e output m√©dio"

fig, ax1 = plt.subplots(figsize=(10, 6))

color1 = 'tab:blue'
ax1.set_xlabel('Dura√ß√£o do Turno (minutos)', fontsize=12)
ax1.set_ylabel('N√∫mero de Trocas', color=color1, fontsize=12)
ax1.plot(summary['stint_min'], summary['n_stints'] - 1, color=color1, marker='s', linewidth=2, label='Trocas')
ax1.tick_params(axis='y', labelcolor=color1)

ax2 = ax1.twinx()
color2 = 'tab:orange'
ax2.set_ylabel('Output M√©dio (%)', color=color2, fontsize=12)
ax2.plot(summary['stint_min'], summary['avg_output'] * 100, color=color2, marker='o', linewidth=2, label='Output')
ax2.tick_params(axis='y', labelcolor=color2)

# Linha vertical no √≥timo
ax1.axvline(x=best_stint, color='red', linestyle='--', alpha=0.5, label=f'√ìtimo: {best_stint} min')

fig.suptitle('Trade-off: Menos Trocas vs. Mais Fadiga', fontsize=14, fontweight='bold')
fig.legend(loc='upper center', bbox_to_anchor=(0.5, 0.02), ncol=3)
plt.tight_layout()
plt.subplots_adjust(bottom=0.15)
plt.show()
```

## Resultado √ìtimo

::: {.callout-tip}
## Configura√ß√£o Recomendada
**Dura√ß√£o do turno: `{python} best_stint` minutos**

Tempo estimado de prova: **`{python} f'{best_time:.1f}'` minutos** (`{python} f'{best_time/60:.1f}'` horas)
:::

### Regras de Rota√ß√£o

Cada remador segue um padr√£o simples de 3 turnos que se repete durante toda a prova:

```{python}
print("Ciclo de Rota√ß√£o (repete a cada 3 turnos):\n")
for name, rule in results['best']['cycle_rules'].items():
    print(f"  {name:12} {rule}")
```



### Ciclo de Rota√ß√£o

O cronograma segue um ciclo de **3 turnos que se repete** durante toda a prova:

```{python}
#| label: tbl-schedule
#| tbl-cap: "Ciclo de rota√ß√£o (turnos 1-3 se repetem)"

schedule = results['best']['schedule'].copy()
schedule.columns = schedule.columns.str.strip()

# Show 6 rows (2 full cycles) to make pattern obvious
n_rows = min(6, len(schedule))
cycle = schedule.head(n_rows).copy()
cycle.index = [f'Turno {i+1}' for i in range(n_rows)]
cycle.columns = ['Banco 1', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6']
cycle
```

```{python}
#| label: fig-heatmap
#| fig-cap: "Ciclo de rota√ß√£o (turnos 1-3 se repetem)"
from matplotlib.patches import Rectangle

# Show 6 rows (2 full cycles)
n_rows = min(6, len(results['best']['schedule']))
schedule_matrix = results['best']['schedule'].head(n_rows).copy()
all_paddlers = set(paddlers['name'])

# Build matrix with paddlers out (resting)
out_matrix = []
for i in range(n_rows):
    in_canoe = set(schedule_matrix.iloc[i].values)
    out = sorted(all_paddlers - in_canoe)
    out_matrix.append(out)
out_df = pd.DataFrame(out_matrix, columns=['Fora 1', 'Fora 2', 'Fora 3'])

# Combine in and out (9 columns total)
combined = pd.concat([schedule_matrix.reset_index(drop=True), out_df], axis=1)
paddler_to_num = {name: i for i, name in enumerate(paddlers['name'])}
combined_numeric = combined.replace(paddler_to_num)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5), gridspec_kw={'width_ratios': [6, 3], 'wspace': 0.05})

# Left plot: seats (in canoe)
im1 = ax1.imshow(combined_numeric.iloc[:, :6].values, cmap='tab10', aspect='auto')
ax1.set_xticks(range(6))
ax1.set_xticklabels(['Banco 1\n(Proa)', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6\n(Leme)'])
ax1.set_yticks(range(n_rows))
ax1.set_yticklabels([f'Turno {i+1}' for i in range(n_rows)])

for i in range(n_rows):
    for j in range(6):
        name = combined.iloc[i, j]
        ax1.text(j, i, name[:3], ha='center', va='center', fontsize=10, fontweight='bold', color='white')

# Highlight first cycle
rect = Rectangle((-0.5, -0.5), 6, 3, linewidth=3, edgecolor='yellow', facecolor='none', linestyle='--')
ax1.add_patch(rect)

# Right plot: out (resting) - same colors as left
im2 = ax2.imshow(combined_numeric.iloc[:, 6:].values, cmap='tab10', aspect='auto')
ax2.set_xticks(range(3))
ax2.set_xticklabels(['Fora 1', 'Fora 2', 'Fora 3'])
ax2.set_yticks(range(n_rows))
ax2.set_yticklabels([])

for i in range(n_rows):
    for j in range(3):
        name = combined.iloc[i, 6 + j]
        ax2.text(j, i, name[:3], ha='center', va='center', fontsize=10, fontweight='bold', color='white')

fig.suptitle(f'Padr√£o de Rota√ß√£o (ciclo de 3 turnos repete {results["best"]["n_stints"] // 3}x)', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()
```

## Resumo

```{python}
n_stints = results['best']['n_stints']
n_trocas = n_stints - 1
velocidade_efetiva = DISTANCIA_KM / (best_time / 60)  # km/h
subidas_por_remador = n_stints / 3  # cada remador entra 1x por ciclo de 3 turnos
```

| M√©trica | Valor |
|---------|-------|
| Dist√¢ncia | `{python} DISTANCIA_KM` km |
| Velocidade base | `{python} VELOCIDADE_KMH` km/h |
| **Velocidade efetiva** | **`{python} f'{velocidade_efetiva:.2f}'` km/h** |
| Dura√ß√£o do turno | `{python} best_stint` min |
| N√∫mero de turnos | `{python} n_stints` |
| N√∫mero de trocas | `{python} n_trocas` |
| Subidas por remador | `{python} f'{subidas_por_remador:.1f}'` (m√©dia) |
| Tempo por troca | `{python} TEMPO_TROCA_SECS` s |
| **Tempo total** | **`{python} f'{best_time:.1f}'` min** (`{python} f'{best_time/60:.1f}'` h) |

---

*Gerado com [Outrigger Optimizer](https://github.com/anthropics/outrigger)*
