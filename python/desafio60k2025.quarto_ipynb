{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Desafio 60K 2025 - Otimização de Rotação\"\n",
        "subtitle: \"Análise de revezamento para canoa havaiana OC6\"\n",
        "author: \"Outrigger Optimizer\"\n",
        "date: today\n",
        "format:\n",
        "  html:\n",
        "    toc: true\n",
        "    toc-depth: 3\n",
        "    code-fold: true\n",
        "    theme: cosmo\n",
        "execute:\n",
        "  warning: false\n",
        "---\n",
        "\n",
        "\n",
        "## Introdução\n",
        "\n",
        "Este documento apresenta a análise de otimização de rotação para o **Desafio 60K 2025**.\n",
        "O objetivo é encontrar a duração ideal de cada turno (período de remada) que minimize o tempo total de prova, considerando:\n",
        "\n",
        "- **Fadiga**: remadores perdem eficiência ao longo de turnos consecutivos\n",
        "- **Trocas**: cada troca de tripulação adiciona tempo à prova\n",
        "- **Elegibilidade**: cada remador só pode ocupar determinados bancos\n",
        "\n",
        "\n",
        "\n",
        "## Configuração da Prova\n"
      ],
      "id": "db360f64"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from outrigger_opt import optimize_stint_range, solve_rotation_cycle\n",
        "\n",
        "# Configuração da prova\n",
        "DISTANCIA_KM = 60\n",
        "VELOCIDADE_KMH = 10\n",
        "TEMPO_TROCA_SECS = 40"
      ],
      "id": "df0394e5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Tripulação\n",
        "\n",
        "A tripulação é composta por 9 remadores, onde 6 remam e 3 descansam a cada turno.\n"
      ],
      "id": "97973ed3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "paddlers = pd.DataFrame({\n",
        "    'name': ['Eduardo', 'Guilherme', 'Vitor', 'Ricardo', 'Airton',\n",
        "             'Everson', 'Sergio', 'Marcelo', 'Zé']\n",
        "})\n",
        "\n",
        "# Habilidade relativa de cada remador (1.0 = média)\n",
        "habilidade = [1.02, 1.0, 1, 1, 1, 1.02, 1, 1.01, 1.02]\n",
        "\n",
        "# Peso de cada remador (kg) - usado para cálculo de trim (balanco)\n",
        "peso = [73, 89, 78, 95, 95, 75, 75, 97, 78]\n",
        "\n",
        "# Tabela da tripulação\n",
        "tripulacao = pd.DataFrame({\n",
        "    'Nome': paddlers['name'],\n",
        "    'Habilidade': [f'{h:.0%}' for h in habilidade],\n",
        "    'Peso (kg)': peso\n",
        "})\n",
        "tripulacao"
      ],
      "id": "b0c0c31c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Matriz de Elegibilidade\n",
        "\n",
        "Cada remador só pode ocupar determinados bancos, baseado em sua experiência e posição preferida.\n"
      ],
      "id": "7c7c9b41"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: tbl-elegibilidade\n",
        "#| tbl-cap: 'Matriz de Elegibilidade (1 = pode sentar, 0 = não pode)'\n",
        "\n",
        "eligibility = np.array([\n",
        "    [1, 1, 0, 0, 0, 0],  # Eduardo\n",
        "    [1, 1, 0, 0, 0, 0],  # Guilherme\n",
        "    [1, 1, 1, 1, 1, 1],  # Vitor\n",
        "    [0, 1, 1, 1, 1, 0],  # Ricardo\n",
        "    [0, 0, 1, 1, 1, 0],  # Airton\n",
        "    [1, 1, 1, 1, 1, 0],  # Everson\n",
        "    [0, 0, 0, 1, 1, 0],  # Sergio\n",
        "    [0, 0, 1, 1, 1, 1],  # Marcelo\n",
        "    [1, 1, 1, 1, 1, 1],  # Zé\n",
        "])\n",
        "\n",
        "# Criar DataFrame para visualização\n",
        "df_elig = pd.DataFrame(\n",
        "    eligibility,\n",
        "    index=paddlers['name'],\n",
        "    columns=['Banco 1 (Voga)', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6 (Leme)']\n",
        ")\n",
        "df_elig.replace({1: '✓', 0: ''})"
      ],
      "id": "tbl-elegibilidade",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-cap: \"Mapa de elegibilidade dos remadores\"\n",
        "\n",
        "# Calculate average and std of eligible seat positions for each paddler\n",
        "seat_positions = np.arange(1, 7)  # 1-6\n",
        "paddler_stats = []\n",
        "for i, name in enumerate(paddlers['name']):\n",
        "    eligible_seats = seat_positions[eligibility[i] == 1]\n",
        "    avg_seat = eligible_seats.mean()\n",
        "    std_seat = eligible_seats.std() if len(eligible_seats) > 1 else 0\n",
        "    paddler_stats.append((i, name, avg_seat, std_seat))\n",
        "\n",
        "# Sort by average (increasing), then by std (decreasing)\n",
        "paddler_stats.sort(key=lambda x: (x[2], -x[3]))\n",
        "sorted_indices = [s[0] for s in paddler_stats]\n",
        "sorted_names = [s[1] for s in paddler_stats]\n",
        "sorted_eligibility = eligibility[sorted_indices]\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "im = ax.imshow(sorted_eligibility, cmap='Blues', aspect='auto')\n",
        "\n",
        "ax.set_xticks(range(6))\n",
        "ax.set_xticklabels(['Banco 1 (Voga)', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6 (Leme)'])\n",
        "ax.set_yticks(range(9))\n",
        "ax.set_yticklabels(sorted_names)\n",
        "\n",
        "# Adicionar texto nas células\n",
        "for i in range(9):\n",
        "    for j in range(6):\n",
        "        text = '✓' if sorted_eligibility[i, j] == 1 else ''\n",
        "        ax.text(j, i, text, ha='center', va='center', fontsize=14)\n",
        "\n",
        "ax.set_title('Matriz de Elegibilidade', fontsize=14, fontweight='bold')\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "8ff6aeda",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Justificativa dos Parâmetros\n",
        "\n",
        "### Padrão de Entrada nos Bancos\n",
        "\n",
        "A rotação tradicional (equipes experientes) segue o padrão:\n",
        "\n",
        "- **Voga**: Remador descansado entra no **banco 1 (voga)** e passa pro 2 na troca seguinte — assim o voga está sempre \"fresco\" (lá ele)\n",
        "\n",
        "Para a equipe **Caveiras**, invertemos esse padrão:\n",
        "\n",
        "::: {.callout-note}\n",
        "## Adaptação para Caveiras\n",
        "**Voga**: Entrar no banco 2 primeiro, esquentar, depois ir pro banco 1.\n",
        "\n",
        "*Justificativa*: O atleta vai subir pro banco 1 provavelmente frio, dificilmente acertará o ritmo de imediato. Melhor entrar no 2, esquentar e acompanhar o voga anterior, e só depois ir pro 1.\n",
        "\n",
        "**Leme**: Marcelo entra no banco 5, depois vai pro 5. Zé direto no 6.\n",
        ":::\n",
        "\n",
        "### Pesos de Entrada (`seat_entry_weights`)\n",
        "\n",
        "Os pesos refletem a preferência de entrada em cada banco (maior = preferido para entrada):\n"
      ],
      "id": "61c10195"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "seat_entry_weights = [1, 2, 1.5, 1.5, 2, 1]\n",
        "seat_names = ['Banco 1 (Voga)', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6 (Leme)']\n",
        "\n",
        "pd.DataFrame({\n",
        "    'Banco': seat_names,\n",
        "    'Peso': seat_entry_weights\n",
        "}).set_index('Banco')"
      ],
      "id": "3c67c1a2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Duração do turno\n",
        "\n",
        "\n",
        "## Otimização\n",
        "\n",
        "Testamos durações de turno entre **10 e 20 minutos** para encontrar o tempo ótimo.\n"
      ],
      "id": "fc51ef2d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "results = optimize_stint_range(\n",
        "    paddlers,\n",
        "    stint_km_range=[1,1.5,2],\n",
        "    seat_eligibility=eligibility,\n",
        "    seat_weights=[1.05, 1.02, 1.02, 1.01, 1.00, 1.10],\n",
        "    seat_entry_weights=seat_entry_weights,\n",
        "    paddler_ability=habilidade,\n",
        "    paddler_weight=peso,\n",
        "    trim_penalty_weight=0.75,\n",
        "    moi_penalty_weight=0.25,\n",
        "    distance_km=DISTANCIA_KM,\n",
        "    speed_kmh=VELOCIDADE_KMH,\n",
        "    switch_time_secs=TEMPO_TROCA_SECS,\n",
        "    max_consecutive=3,\n",
        "    solver_time_secs=60,\n",
        "    gap_tolerance=0.001,\n",
        ")"
      ],
      "id": "25e8388d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Comparação de Tempos\n"
      ],
      "id": "bcc54cf6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-comparacao\n",
        "#| fig-cap: Tempo de prova vs. duração do turno\n",
        "\n",
        "summary = results['summary']\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "# Gráfico principal\n",
        "ax.plot(summary['stint_min'], summary['race_time'], 'b-o', linewidth=2, markersize=8)\n",
        "\n",
        "# Destacar o melhor\n",
        "best_idx = summary['race_time'].idxmin()\n",
        "best_stint = int(summary.loc[best_idx, 'stint_min'])\n",
        "best_time = summary.loc[best_idx, 'race_time']\n",
        "\n",
        "ax.scatter([best_stint], [best_time], color='red', s=200, zorder=5, label=f'Ótimo: {best_stint} min')\n",
        "ax.axhline(y=best_time, color='red', linestyle='--', alpha=0.5)\n",
        "ax.axvline(x=best_stint, color='red', linestyle='--', alpha=0.5)\n",
        "\n",
        "ax.set_xlabel('Duração do Turno (minutos)', fontsize=12)\n",
        "ax.set_ylabel('Tempo Total de Prova (minutos)', fontsize=12)\n",
        "ax.set_title('Otimização da Duração do Turno', fontsize=14, fontweight='bold')\n",
        "ax.legend()\n",
        "ax.grid(True, alpha=0.3)\n",
        "\n",
        "# Adicionar anotação\n",
        "ax.annotate(f'{best_time:.1f} min\\n({best_time/60:.1f} horas)',\n",
        "            xy=(best_stint, best_time),\n",
        "            xytext=(best_stint + 2, best_time + 3),\n",
        "            fontsize=11,\n",
        "            arrowprops=dict(arrowstyle='->', color='red'))\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-comparacao",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Tabela de Resultados\n"
      ],
      "id": "9ea7f0dc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: tbl-resultados\n",
        "#| tbl-cap: Comparação de tempos por duração de turno\n",
        "\n",
        "summary_display = summary.copy()\n",
        "summary_display['race_time_hours'] = summary_display['race_time'] / 60\n",
        "summary_display['speed'] = DISTANCIA_KM / summary_display['race_time_hours']\n",
        "summary_display.columns = ['Turno (min)', 'Nº turnos', 'Output Médio', 'Tempo (min)', 'Tempo (horas)', 'Velocidade (km/h)']\n",
        "summary_display['Output Médio'] = summary_display['Output Médio'].apply(lambda x: f'{x:.1%}')\n",
        "summary_display['Tempo (horas)'] = summary_display['Tempo (horas)'].apply(lambda x: f'{x:.2f}')\n",
        "summary_display['Velocidade (km/h)'] = summary_display['Velocidade (km/h)'].apply(lambda x: f'{x:.2f}')\n",
        "summary_display = summary_display.drop(columns=['Tempo (min)'])\n",
        "summary_display.set_index('Turno (min)', inplace=True)\n",
        "summary_display"
      ],
      "id": "tbl-resultados",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Trade-off: Trocas vs. Fadiga\n"
      ],
      "id": "a637a550"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-tradeoff\n",
        "#| fig-cap: Análise do trade-off entre número de trocas e output médio\n",
        "\n",
        "fig, ax1 = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "color1 = 'tab:blue'\n",
        "ax1.set_xlabel('Duração do Turno (minutos)', fontsize=12)\n",
        "ax1.set_ylabel('Número de Trocas', color=color1, fontsize=12)\n",
        "ax1.plot(summary['stint_min'], summary['n_stints'] - 1, color=color1, marker='s', linewidth=2, label='Trocas')\n",
        "ax1.tick_params(axis='y', labelcolor=color1)\n",
        "\n",
        "ax2 = ax1.twinx()\n",
        "color2 = 'tab:orange'\n",
        "ax2.set_ylabel('Output Médio (%)', color=color2, fontsize=12)\n",
        "ax2.plot(summary['stint_min'], summary['avg_output'] * 100, color=color2, marker='o', linewidth=2, label='Output')\n",
        "ax2.tick_params(axis='y', labelcolor=color2)\n",
        "\n",
        "# Linha vertical no ótimo\n",
        "ax1.axvline(x=best_stint, color='red', linestyle='--', alpha=0.5, label=f'Ótimo: {best_stint} min')\n",
        "\n",
        "fig.suptitle('Trade-off: Menos Trocas vs. Mais Fadiga', fontsize=14, fontweight='bold')\n",
        "fig.legend(loc='upper center', bbox_to_anchor=(0.5, 0.02), ncol=3)\n",
        "plt.tight_layout()\n",
        "plt.subplots_adjust(bottom=0.15)\n",
        "plt.show()"
      ],
      "id": "fig-tradeoff",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Resultado Ótimo\n",
        "\n",
        "::: {.callout-tip}\n",
        "## Configuração Recomendada\n",
        "**Duração do turno: `{python} best_stint` minutos**\n",
        "\n",
        "Tempo estimado de prova: **`{python} f'{best_time:.1f}'` minutos** (`{python} f'{best_time/60:.1f}'` horas)\n",
        ":::\n",
        "\n",
        "### Regras de Rotação\n",
        "\n",
        "Cada remador segue um padrão simples de 3 turnos que se repete durante toda a prova:\n"
      ],
      "id": "421e4f4a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"Ciclo de Rotação (repete a cada 3 turnos):\\n\")\n",
        "for name, rule in results['best']['cycle_rules'].items():\n",
        "    print(f\"  {name:12} {rule}\")"
      ],
      "id": "e045ee15",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Ciclo de Rotação\n",
        "\n",
        "O cronograma segue um ciclo de **3 turnos que se repete** durante toda a prova:\n"
      ],
      "id": "d9d7df0f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: tbl-schedule\n",
        "#| tbl-cap: Ciclo de rotação (turnos 1-3 se repetem)\n",
        "\n",
        "schedule = results['best']['schedule'].copy()\n",
        "schedule.columns = schedule.columns.str.strip()\n",
        "\n",
        "# Show 6 rows (2 full cycles) to make pattern obvious\n",
        "n_rows = min(6, len(schedule))\n",
        "cycle = schedule.head(n_rows).copy()\n",
        "cycle.index = [f'Turno {i+1}' for i in range(n_rows)]\n",
        "cycle.columns = ['Banco 1', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6']\n",
        "cycle"
      ],
      "id": "tbl-schedule",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: tbl-cycle-stats\n",
        "#| tbl-cap: Estatísticas por turno do ciclo\n",
        "\n",
        "# Calculate per-stint statistics\n",
        "params = results['best']['parameters']\n",
        "trim_stats = params.get('trim_stats')\n",
        "seat_positions = trim_stats['seat_positions'] if trim_stats else [-2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n",
        "name_to_weight = dict(zip(paddlers['name'], peso))\n",
        "name_to_ability = dict(zip(paddlers['name'], habilidade))\n",
        "seat_weights = [1.05, 1.02, 1.02, 1.01, 1.00, 1.10]\n",
        "\n",
        "cycle_stats = []\n",
        "for t in range(3):  # cycle length = 3\n",
        "    row = results['best']['cycle_schedule'].iloc[t]\n",
        "\n",
        "    # Calculate weighted power output (sum of ability * seat_weight)\n",
        "    power = sum(name_to_ability.get(name, 1.0) * seat_weights[s] for s, name in enumerate(row))\n",
        "\n",
        "    # Calculate trim moment\n",
        "    trim = sum(name_to_weight.get(name, 75) * seat_positions[s] for s, name in enumerate(row))\n",
        "\n",
        "    # Speed is proportional to power (simplified)\n",
        "    base_speed = VELOCIDADE_KMH\n",
        "    speed = base_speed * (power / sum(seat_weights))  # Normalize by ideal power\n",
        "\n",
        "    cycle_stats.append({\n",
        "        'Turno': f'{t+1}',\n",
        "        'Output': f'{power:.2f}',\n",
        "        'Velocidade (km/h)': f'{speed:.2f}',\n",
        "        'Trim (kg-m)': f'{trim:+.1f}',\n",
        "    })\n",
        "\n",
        "pd.DataFrame(cycle_stats).set_index('Turno')"
      ],
      "id": "tbl-cycle-stats",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-heatmap\n",
        "#| fig-cap: Ciclo de rotação (turnos 1-3 se repetem)\n",
        "from matplotlib.patches import Rectangle\n",
        "\n",
        "# Show 6 rows (2 full cycles)\n",
        "n_rows = min(6, len(results['best']['schedule']))\n",
        "schedule_matrix = results['best']['schedule'].head(n_rows).copy()\n",
        "all_paddlers = set(paddlers['name'])\n",
        "\n",
        "# Build matrix with paddlers out (resting)\n",
        "out_matrix = []\n",
        "for i in range(n_rows):\n",
        "    in_canoe = set(schedule_matrix.iloc[i].values)\n",
        "    out = sorted(all_paddlers - in_canoe)\n",
        "    out_matrix.append(out)\n",
        "out_df = pd.DataFrame(out_matrix, columns=['Fora 1', 'Fora 2', 'Fora 3'])\n",
        "\n",
        "# Combine in and out (9 columns total)\n",
        "combined = pd.concat([schedule_matrix.reset_index(drop=True), out_df], axis=1)\n",
        "paddler_to_num = {name: i for i, name in enumerate(paddlers['name'])}\n",
        "combined_numeric = combined.replace(paddler_to_num)\n",
        "\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5), gridspec_kw={'width_ratios': [6, 3], 'wspace': 0.05})\n",
        "\n",
        "# Left plot: seats (in canoe)\n",
        "im1 = ax1.imshow(combined_numeric.iloc[:, :6].values, cmap='tab10', aspect='auto')\n",
        "ax1.set_xticks(range(6))\n",
        "ax1.set_xticklabels(['Banco 1\\n(Voga)', 'Banco 2', 'Banco 3', 'Banco 4', 'Banco 5', 'Banco 6\\n(Leme)'])\n",
        "ax1.set_yticks(range(n_rows))\n",
        "ax1.set_yticklabels([f'Turno {i+1}' for i in range(n_rows)])\n",
        "\n",
        "for i in range(n_rows):\n",
        "    for j in range(6):\n",
        "        name = combined.iloc[i, j]\n",
        "        ax1.text(j, i, name[:3], ha='center', va='center', fontsize=10, fontweight='bold', color='white')\n",
        "\n",
        "# Highlight first cycle\n",
        "rect = Rectangle((-0.5, -0.5), 6, 3, linewidth=3, edgecolor='yellow', facecolor='none', linestyle='--')\n",
        "ax1.add_patch(rect)\n",
        "\n",
        "# Right plot: out (resting) - same colors as left\n",
        "im2 = ax2.imshow(combined_numeric.iloc[:, 6:].values, cmap='tab10', aspect='auto')\n",
        "ax2.set_xticks(range(3))\n",
        "ax2.set_xticklabels(['Fora 1', 'Fora 2', 'Fora 3'])\n",
        "ax2.set_yticks(range(n_rows))\n",
        "ax2.set_yticklabels([])\n",
        "\n",
        "for i in range(n_rows):\n",
        "    for j in range(3):\n",
        "        name = combined.iloc[i, 6 + j]\n",
        "        ax2.text(j, i, name[:3], ha='center', va='center', fontsize=10, fontweight='bold', color='white')\n",
        "\n",
        "fig.suptitle(f'Padrão de Rotação (ciclo de 3 turnos repete {results[\"best\"][\"n_stints\"] // 3}x)', fontsize=14, fontweight='bold')\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-heatmap",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Análise de Trim e Concentração de Peso\n",
        "\n",
        "O modelo considera dois aspectos do balanço da canoa:\n",
        "\n",
        "- **Trim (momento)**: Balanço proa-popa. Positivo = pesada na popa, negativo = pesada na proa.\n",
        "- **MOI (inércia)**: Concentração de peso. Menor = peso no centro, maior = peso nas pontas.\n"
      ],
      "id": "b7c33634"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: tbl-trim\n",
        "#| tbl-cap: Análise de trim e MOI por turno do ciclo\n",
        "\n",
        "trim_stats = results['best'].get('parameters', {}).get('trim_stats')\n",
        "if trim_stats:\n",
        "    print(f\"Momento de trim médio (absoluto): {trim_stats['avg_abs_trim_moment']:.1f} kg-m\")\n",
        "    print(f\"Momento de trim máximo (absoluto): {trim_stats['max_abs_trim_moment']:.1f} kg-m\")\n",
        "    print(f\"MOI médio: {trim_stats.get('avg_moi', 0):.1f} kg-m²\")\n",
        "    print(f\"\\nPor turno do ciclo:\")\n",
        "    moi_values = trim_stats.get('moi_values', [0] * len(trim_stats['trim_moments']))\n",
        "    for t, (m, moi) in enumerate(zip(trim_stats['trim_moments'], moi_values)):\n",
        "        direcao = \"popa\" if m > 0 else \"proa\" if m < 0 else \"neutro\"\n",
        "        print(f\"  Turno {t+1}: Trim={m:+.1f} kg-m ({direcao}), MOI={moi:.1f} kg-m²\")\n",
        "else:\n",
        "    print(\"Análise não disponível (trim_penalty_weight = 0 e moi_penalty_weight = 0)\")"
      ],
      "id": "tbl-trim",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Resumo\n"
      ],
      "id": "ab73a3e9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "n_stints = results['best']['n_stints']\n",
        "n_trocas = n_stints - 1\n",
        "velocidade_efetiva = DISTANCIA_KM / (best_time / 60)  # km/h\n",
        "subidas_por_remador = n_stints / 3  # cada remador entra 1x por ciclo de 3 turnos"
      ],
      "id": "52cce239",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "| Métrica | Valor |\n",
        "|---------|-------|\n",
        "| Distância | `{python} DISTANCIA_KM` km |\n",
        "| Velocidade base | `{python} VELOCIDADE_KMH` km/h |\n",
        "| **Velocidade efetiva** | **`{python} f'{velocidade_efetiva:.2f}'` km/h** |\n",
        "| Duração do turno | `{python} best_stint` min |\n",
        "| Número de turnos | `{python} n_stints` |\n",
        "| Número de trocas | `{python} n_trocas` |\n",
        "| Subidas por remador | `{python} f'{subidas_por_remador:.1f}'` (média) |\n",
        "| Tempo por troca | `{python} TEMPO_TROCA_SECS` s |\n",
        "| **Tempo total** | **`{python} f'{best_time:.1f}'` min** (`{python} f'{best_time/60:.1f}'` h) |\n",
        "\n",
        "---\n",
        "\n",
        "*Gerado com [Outrigger Optimizer](https://github.com/anthropics/outrigger)*"
      ],
      "id": "20c64e89"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/eleon/github/outrigger/python/.venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}